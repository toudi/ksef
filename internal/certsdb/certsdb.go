package certsdb

import (
	"errors"
	"ksef/internal/logging"
	"ksef/internal/runtime"
	"ksef/internal/utils"
	"os"
	"path"
	"slices"
	"time"

	"github.com/samber/lo"
	"gopkg.in/yaml.v3"
)

var (
	ErrCertificateNotFound  = errors.New("unable to find a certificate suitable for the selected usage")
	errDecodingCertificates = errors.New("unable to decode certificates array from file")
)

type (
	Usage string
)

func (u Usage) Description() string {
	if u == UsageAuthentication {
		return "certyfikat autoryzacyjny"
	} else if u == UsageOffline {
		return "certyfikat offline"
	}
	panic("nieoczekiwana wartość Usage")
}

const (
	certificatesDBFile = "certificates/certificates.yaml"
	// certyfikaty RSA używane przez ministerstwo finansów
	UsageTokenEncryption        Usage = "KsefTokenEncryption"
	UsageSymmetricKeyEncryption Usage = "SymmetricKeyEncryption"
)

type CertificatesDB struct {
	certs []*Certificate
	// whether the db requires to be saved
	dirty bool
	// map between certificate hash and it's position in the array
	index map[string]int
	// map between certificate UID and it's position in the array - required only for adding new certificates
	uidIndex map[string]int
	// used during opening so that all of the certs inserted inherit this value
	env runtime.Gateway
}

func (cdb *CertificatesDB) Certs() []*Certificate {
	return cdb.certs
}

func (cdb *CertificatesDB) GetByUsage(usage Usage, nip string) (Certificate, error) {
	var foundCerts []Certificate

	var now = time.Now()

	for _, cert := range cdb.certs {
		if !slices.Contains(cert.Usage, usage) || !cert.available {
			continue
		}
		if cert.ValidFrom.After(now) || cert.ValidTo.Before(now) {
			logging.CertsDBLogger.Debug("certyfikat poza zakresem ważności", "id", cert.UID)
			continue
		}
		// self-signed certificates do not need to have a NIP. they can - if they're
		// generated by NIP rather than by PESEL
		if nip != "" && cert.NIP != nip && !cert.SelfSigned {
			logging.CertsDBLogger.Debug("certyfikat wystawiony dla innego numeru NIP", "id", cert.UID)
			continue
		}

		foundCerts = append(foundCerts, *cert)
	}

	// for Authentication there are two possible choices - self-signed and ksef-issued.
	// let's sort the list in that order and try to use ksef-issued (if it hasn't expired yet)
	// and the self-signed (if it exists)

	if foundCerts != nil {
		slices.SortFunc(foundCerts, func(a, b Certificate) int {
			if a.SelfSigned && !b.SelfSigned {
				return 1
			} else if !a.SelfSigned && b.SelfSigned {
				return -1
			}
			return 0
		})

		logging.CertsDBLogger.Debug("wybrano certyfikat", "id", foundCerts[0].UID, "typ", foundCerts[0].Usage, "self-signed", foundCerts[0].SelfSigned)

		return foundCerts[0], nil
	}

	return Certificate{}, ErrCertificateNotFound
}

func (cdb *CertificatesDB) Save() error {
	for _, cert := range cdb.certs {
		if cert.Expired() {
			// logging.CertsDBLogger.With("id", cert.UID).Warn("certyfikat stracił ważność - usuwam plik")
			os.Remove(cert.Filename())
			cert.removed = true
			cdb.dirty = true
		}
	}

	if !cdb.dirty {
		return nil
	}

	cdb.certs = lo.Filter(cdb.certs, func(item *Certificate, _ int) bool {
		return !item.removed
	})

	targetFile, err := os.Create(certificatesDBFile)
	if err != nil {
		return err
	}
	defer func() {
		targetFile.Close()
		cdb.dirty = false
	}()
	encoder := yaml.NewEncoder(targetFile)
	return encoder.Encode(cdb.certs)
}

func OpenOrCreate(environment runtime.Gateway) (*CertificatesDB, error) {
	var certificatesDB = CertificatesDB{
		index:    make(map[string]int),
		uidIndex: make(map[string]int),
		env:      environment,
	}

	if err := os.MkdirAll(path.Dir(certificatesDBFile), 0775); err != nil {
		return nil, err
	}
	dbFile, exists, err := utils.FileExists(certificatesDBFile)
	// isNotExist is fine
	if err != nil && !os.IsNotExist(err) {
		return nil, err
	}

	// if the error was that the file does not exist then there's no point
	// reading any certs as there won't be any
	if exists {
		defer dbFile.Close()
		var certificates []*Certificate
		if err = utils.ReadYAML(dbFile, &certificates); err != nil {
			return nil, errors.Join(errDecodingCertificates, err)
		}

		certificatesDB.certs = certificates

		for index, cert := range certificates {
			// load up only the certificates that belong to the selected environment
			cert.available = cert.Environment == environment
			certificatesDB.index[cert.Hash()] = index
			certificatesDB.uidIndex[cert.UID] = index
		}
	}

	return &certificatesDB, nil
}
